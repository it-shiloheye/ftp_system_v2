// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: client_queries.sql

package db_access

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const connectClient = `-- name: ConnectClient :many
SELECT id, peer_id, ip_address, peer_role, peer_name, pem FROM peers_table
WHERE (
     ip_address = $1
     AND 
     peer_id = $2
)
LIMIT 1
`

type ConnectClientParams struct {
	IpAddress string      `json:"ip_address"`
	PeerID    pgtype.UUID `json:"peer_id"`
}

// ConnectClient
//
//	SELECT id, peer_id, ip_address, peer_role, peer_name, pem FROM peers_table
//	WHERE (
//	     ip_address = $1
//	     AND
//	     peer_id = $2
//	)
//	LIMIT 1
func (q *Queries) ConnectClient(ctx context.Context, db DBTX, arg *ConnectClientParams) ([]*PeersTable, error) {
	rows, err := db.Query(ctx, connectClient, arg.IpAddress, arg.PeerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PeersTable{}
	for rows.Next() {
		var i PeersTable
		if err := rows.Scan(
			&i.ID,
			&i.PeerID,
			&i.IpAddress,
			&i.PeerRole,
			&i.PeerName,
			&i.Pem,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countIfStored = `-- name: CountIfStored :one
SELECT COUNT(*) FROM file_storage
WHERE 
    (
        file_hash = $1
        OR 
        prev_file_hash = $1
    )
AND
    file_state = 'stored'
`

// CountIfStored
//
//	SELECT COUNT(*) FROM file_storage
//	WHERE
//	    (
//	        file_hash = $1
//	        OR
//	        prev_file_hash = $1
//	    )
//	AND
//	    file_state = 'stored'
func (q *Queries) CountIfStored(ctx context.Context, db DBTX, fileHash *string) (int64, error) {
	row := db.QueryRow(ctx, countIfStored, fileHash)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createClient = `-- name: CreateClient :many
INSERT INTO peers_table(peer_id,ip_address, PEM,peer_role)
VALUES  (default,$1, $2,$3)
RETURNING id, peer_id, ip_address, peer_role, peer_name, pem
`

type CreateClientParams struct {
	IpAddress string           `json:"ip_address"`
	Pem       []byte           `json:"pem"`
	PeerRole  NullPeerRoleType `json:"peer_role"`
}

// CreateClient
//
//	INSERT INTO peers_table(peer_id,ip_address, PEM,peer_role)
//	VALUES  (default,$1, $2,$3)
//	RETURNING id, peer_id, ip_address, peer_role, peer_name, pem
func (q *Queries) CreateClient(ctx context.Context, db DBTX, arg *CreateClientParams) ([]*PeersTable, error) {
	rows, err := db.Query(ctx, createClient, arg.IpAddress, arg.Pem, arg.PeerRole)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PeersTable{}
	for rows.Next() {
		var i PeersTable
		if err := rows.Scan(
			&i.ID,
			&i.PeerID,
			&i.IpAddress,
			&i.PeerRole,
			&i.PeerName,
			&i.Pem,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const downloadFiles = `-- name: DownloadFiles :many
SELECT
    file_hash,
    file_name,
    file_data,
    modification_date
FROM file_storage
WHERE 
    peer_id = $1
    AND
    file_state != 'deleted'
    AND
    file_data IS NOT NULL
`

type DownloadFilesRow struct {
	FileHash         *string          `json:"file_hash"`
	FileName         string           `json:"file_name"`
	FileData         []byte           `json:"file_data"`
	ModificationDate pgtype.Timestamp `json:"modification_date"`
}

// DownloadFiles
//
//	SELECT
//	    file_hash,
//	    file_name,
//	    file_data,
//	    modification_date
//	FROM file_storage
//	WHERE
//	    peer_id = $1
//	    AND
//	    file_state != 'deleted'
//	    AND
//	    file_data IS NOT NULL
func (q *Queries) DownloadFiles(ctx context.Context, db DBTX, peerID uuid.UUID) ([]*DownloadFilesRow, error) {
	rows, err := db.Query(ctx, downloadFiles, peerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DownloadFilesRow{}
	for rows.Next() {
		var i DownloadFilesRow
		if err := rows.Scan(
			&i.FileHash,
			&i.FileName,
			&i.FileData,
			&i.ModificationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPem = `-- name: GetAllPem :many
SELECT pem FROM peers_table
`

// GetAllPem
//
//	SELECT pem FROM peers_table
func (q *Queries) GetAllPem(ctx context.Context, db DBTX) ([][]byte, error) {
	rows, err := db.Query(ctx, getAllPem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := [][]byte{}
	for rows.Next() {
		var pem []byte
		if err := rows.Scan(&pem); err != nil {
			return nil, err
		}
		items = append(items, pem)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountOfStoragePeers = `-- name: GetCountOfStoragePeers :one
SELECT COUNT(*) FROM peers_table 
WHERE peer_role = 'storage'
`

// GetCountOfStoragePeers
//
//	SELECT COUNT(*) FROM peers_table
//	WHERE peer_role = 'storage'
func (q *Queries) GetCountOfStoragePeers(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, getCountOfStoragePeers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFileData = `-- name: GetFileData :many
SELECT 
    peer_id,
    file_state,
    file_data
FROM file_storage 
WHERE file_hash = $1
LIMIT 1
`

type GetFileDataRow struct {
	PeerID    uuid.UUID          `json:"peer_id"`
	FileState NullFileStatusType `json:"file_state"`
	FileData  []byte             `json:"file_data"`
}

// GetFileData
//
//	SELECT
//	    peer_id,
//	    file_state,
//	    file_data
//	FROM file_storage
//	WHERE file_hash = $1
//	LIMIT 1
func (q *Queries) GetFileData(ctx context.Context, db DBTX, fileHash *string) ([]*GetFileDataRow, error) {
	rows, err := db.Query(ctx, getFileData, fileHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFileDataRow{}
	for rows.Next() {
		var i GetFileDataRow
		if err := rows.Scan(&i.PeerID, &i.FileState, &i.FileData); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFiles = `-- name: GetFiles :many
SELECT 
    file_name,
    file_path,
    file_type,
    modification_date,
    file_state,
    file_hash,
    prev_file_hash
 FROM file_storage 
WHERE peer_id = $1
ORDER BY modification_date DESC
`

type GetFilesRow struct {
	FileName         string             `json:"file_name"`
	FilePath         string             `json:"file_path"`
	FileType         string             `json:"file_type"`
	ModificationDate pgtype.Timestamp   `json:"modification_date"`
	FileState        NullFileStatusType `json:"file_state"`
	FileHash         *string            `json:"file_hash"`
	PrevFileHash     *string            `json:"prev_file_hash"`
}

// GetFiles
//
//	SELECT
//	    file_name,
//	    file_path,
//	    file_type,
//	    modification_date,
//	    file_state,
//	    file_hash,
//	    prev_file_hash
//	 FROM file_storage
//	WHERE peer_id = $1
//	ORDER BY modification_date DESC
func (q *Queries) GetFiles(ctx context.Context, db DBTX, peerID uuid.UUID) ([]*GetFilesRow, error) {
	rows, err := db.Query(ctx, getFiles, peerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFilesRow{}
	for rows.Next() {
		var i GetFilesRow
		if err := rows.Scan(
			&i.FileName,
			&i.FilePath,
			&i.FileType,
			&i.ModificationDate,
			&i.FileState,
			&i.FileHash,
			&i.PrevFileHash,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFile = `-- name: InsertFile :one
INSERT INTO file_storage (
    peer_id,
    file_name,
    file_path, 
    file_type,
    modification_date,
    file_state,
    file_data
) VALUES ( 
    $1, $2, $3, $4, $5, $6, $7
) RETURNING 
    id,
    file_hash
`

type InsertFileParams struct {
	PeerID           uuid.UUID          `json:"peer_id"`
	FileName         string             `json:"file_name"`
	FilePath         string             `json:"file_path"`
	FileType         string             `json:"file_type"`
	ModificationDate pgtype.Timestamp   `json:"modification_date"`
	FileState        NullFileStatusType `json:"file_state"`
	FileData         []byte             `json:"file_data"`
}

type InsertFileRow struct {
	ID       int32   `json:"id"`
	FileHash *string `json:"file_hash"`
}

// InsertFile
//
//	INSERT INTO file_storage (
//	    peer_id,
//	    file_name,
//	    file_path,
//	    file_type,
//	    modification_date,
//	    file_state,
//	    file_data
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7
//	) RETURNING
//	    id,
//	    file_hash
func (q *Queries) InsertFile(ctx context.Context, db DBTX, arg *InsertFileParams) (*InsertFileRow, error) {
	row := db.QueryRow(ctx, insertFile,
		arg.PeerID,
		arg.FileName,
		arg.FilePath,
		arg.FileType,
		arg.ModificationDate,
		arg.FileState,
		arg.FileData,
	)
	var i InsertFileRow
	err := row.Scan(&i.ID, &i.FileHash)
	return &i, err
}

const markFileDeleted = `-- name: MarkFileDeleted :exec
UPDATE file_storage
SET 
    file_state = 'deleted'
WHERE
    peer_id = $1
    AND 
    file_hash = $2
    AND 
    file_state != 'deleted'
`

type MarkFileDeletedParams struct {
	PeerID   uuid.UUID `json:"peer_id"`
	FileHash *string   `json:"file_hash"`
}

// MarkFileDeleted
//
//	UPDATE file_storage
//	SET
//	    file_state = 'deleted'
//	WHERE
//	    peer_id = $1
//	    AND
//	    file_hash = $2
//	    AND
//	    file_state != 'deleted'
func (q *Queries) MarkFileDeleted(ctx context.Context, db DBTX, arg *MarkFileDeletedParams) error {
	_, err := db.Exec(ctx, markFileDeleted, arg.PeerID, arg.FileHash)
	return err
}

const updateFileLog = `-- name: UpdateFileLog :exec
INSERT  INTO file_log (
    peer_id,
    file_hash,
    current_file_status,
    old_file_status 
) VALUES 
    ($1, $2, $3, $4)
`

type UpdateFileLogParams struct {
	PeerID            uuid.UUID          `json:"peer_id"`
	FileHash          string             `json:"file_hash"`
	CurrentFileStatus NullFileStatusType `json:"current_file_status"`
	OldFileStatus     NullFileStatusType `json:"old_file_status"`
}

// UpdateFileLog
//
//	INSERT  INTO file_log (
//	    peer_id,
//	    file_hash,
//	    current_file_status,
//	    old_file_status
//	) VALUES
//	    ($1, $2, $3, $4)
func (q *Queries) UpdateFileLog(ctx context.Context, db DBTX, arg *UpdateFileLogParams) error {
	_, err := db.Exec(ctx, updateFileLog,
		arg.PeerID,
		arg.FileHash,
		arg.CurrentFileStatus,
		arg.OldFileStatus,
	)
	return err
}

const updatePeerRole = `-- name: UpdatePeerRole :exec
UPDATE peers_table
SET 
    peer_role = $2
WHERE 
    peer_id = $1
`

type UpdatePeerRoleParams struct {
	PeerID   pgtype.UUID      `json:"peer_id"`
	PeerRole NullPeerRoleType `json:"peer_role"`
}

// UpdatePeerRole
//
//	UPDATE peers_table
//	SET
//	    peer_role = $2
//	WHERE
//	    peer_id = $1
func (q *Queries) UpdatePeerRole(ctx context.Context, db DBTX, arg *UpdatePeerRoleParams) error {
	_, err := db.Exec(ctx, updatePeerRole, arg.PeerID, arg.PeerRole)
	return err
}
