// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: client_queries.sql

package db_access

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const connectClient = `-- name: ConnectClient :many
SELECT id, peer_id, ip_address, peer_role, pem FROM peers_table
WHERE ip_address = $1
LIMIT 1
`

// ConnectClient
//
//	SELECT id, peer_id, ip_address, peer_role, pem FROM peers_table
//	WHERE ip_address = $1
//	LIMIT 1
func (q *Queries) ConnectClient(ctx context.Context, db DBTX, ipAddress string) ([]*PeersTable, error) {
	rows, err := db.Query(ctx, connectClient, ipAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PeersTable{}
	for rows.Next() {
		var i PeersTable
		if err := rows.Scan(
			&i.ID,
			&i.PeerID,
			&i.IpAddress,
			&i.PeerRole,
			&i.Pem,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createClient = `-- name: CreateClient :many
INSERT INTO peers_table(peer_id,ip_address, PEM )
VALUES  (default,$1, $2)
RETURNING (peer_id)
`

type CreateClientParams struct {
	IpAddress string `json:"ip_address"`
	Pem       []byte `json:"pem"`
}

// CreateClient
//
//	INSERT INTO peers_table(peer_id,ip_address, PEM )
//	VALUES  (default,$1, $2)
//	RETURNING (peer_id)
func (q *Queries) CreateClient(ctx context.Context, db DBTX, arg *CreateClientParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, createClient, arg.IpAddress, arg.Pem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var peer_id pgtype.UUID
		if err := rows.Scan(&peer_id); err != nil {
			return nil, err
		}
		items = append(items, peer_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPem = `-- name: GetAllPem :many
SELECT (pem) FROM peers_table
`

// GetAllPem
//
//	SELECT (pem) FROM peers_table
func (q *Queries) GetAllPem(ctx context.Context, db DBTX) ([][]byte, error) {
	rows, err := db.Query(ctx, getAllPem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := [][]byte{}
	for rows.Next() {
		var pem []byte
		if err := rows.Scan(&pem); err != nil {
			return nil, err
		}
		items = append(items, pem)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileData = `-- name: GetFileData :many
SELECT 
    peer_id,
    file_state,
    file_data
FROM file_storage 
WHERE file_hash = $1
LIMIT 1
`

type GetFileDataRow struct {
	PeerID    uuid.UUID          `json:"peer_id"`
	FileState NullFileStatusType `json:"file_state"`
	FileData  []byte             `json:"file_data"`
}

// GetFileData
//
//	SELECT
//	    peer_id,
//	    file_state,
//	    file_data
//	FROM file_storage
//	WHERE file_hash = $1
//	LIMIT 1
func (q *Queries) GetFileData(ctx context.Context, db DBTX, fileHash *string) ([]*GetFileDataRow, error) {
	rows, err := db.Query(ctx, getFileData, fileHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFileDataRow{}
	for rows.Next() {
		var i GetFileDataRow
		if err := rows.Scan(&i.PeerID, &i.FileState, &i.FileData); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFiles = `-- name: GetFiles :many
SELECT 
    file_name,
    file_path,
    file_type,
    modification_date,
    file_state,
    file_hash,
    prev_file_hash
 FROM file_storage 
WHERE peer_id = $1
`

type GetFilesRow struct {
	FileName         string             `json:"file_name"`
	FilePath         string             `json:"file_path"`
	FileType         string             `json:"file_type"`
	ModificationDate pgtype.Timestamp   `json:"modification_date"`
	FileState        NullFileStatusType `json:"file_state"`
	FileHash         *string            `json:"file_hash"`
	PrevFileHash     *string            `json:"prev_file_hash"`
}

// GetFiles
//
//	SELECT
//	    file_name,
//	    file_path,
//	    file_type,
//	    modification_date,
//	    file_state,
//	    file_hash,
//	    prev_file_hash
//	 FROM file_storage
//	WHERE peer_id = $1
func (q *Queries) GetFiles(ctx context.Context, db DBTX, peerID uuid.UUID) ([]*GetFilesRow, error) {
	rows, err := db.Query(ctx, getFiles, peerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFilesRow{}
	for rows.Next() {
		var i GetFilesRow
		if err := rows.Scan(
			&i.FileName,
			&i.FilePath,
			&i.FileType,
			&i.ModificationDate,
			&i.FileState,
			&i.FileHash,
			&i.PrevFileHash,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFile = `-- name: InsertFile :one
INSERT INTO file_storage (
    peer_id,
    file_name,
    file_path,
    file_type,
    modification_date,
    file_state,
    file_data
) VALUES ( 
    $1, $2, $3, $4, $5, $6, $7
) RETURNING 
    id,
    file_hash
`

type InsertFileParams struct {
	PeerID           uuid.UUID          `json:"peer_id"`
	FileName         string             `json:"file_name"`
	FilePath         string             `json:"file_path"`
	FileType         string             `json:"file_type"`
	ModificationDate pgtype.Timestamp   `json:"modification_date"`
	FileState        NullFileStatusType `json:"file_state"`
	FileData         []byte             `json:"file_data"`
}

type InsertFileRow struct {
	ID       int32   `json:"id"`
	FileHash *string `json:"file_hash"`
}

// InsertFile
//
//	INSERT INTO file_storage (
//	    peer_id,
//	    file_name,
//	    file_path,
//	    file_type,
//	    modification_date,
//	    file_state,
//	    file_data
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7
//	) RETURNING
//	    id,
//	    file_hash
func (q *Queries) InsertFile(ctx context.Context, db DBTX, arg *InsertFileParams) (*InsertFileRow, error) {
	row := db.QueryRow(ctx, insertFile,
		arg.PeerID,
		arg.FileName,
		arg.FilePath,
		arg.FileType,
		arg.ModificationDate,
		arg.FileState,
		arg.FileData,
	)
	var i InsertFileRow
	err := row.Scan(&i.ID, &i.FileHash)
	return &i, err
}
