// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: client_queries.sql

package db_access

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const connectClient = `-- name: ConnectClient :many
SELECT id, peer_id, ip_address, pem FROM peers_table
WHERE ip_address = $1
LIMIT 1
`

// ConnectClient
//
//	SELECT id, peer_id, ip_address, pem FROM peers_table
//	WHERE ip_address = $1
//	LIMIT 1
func (q *Queries) ConnectClient(ctx context.Context, db DBTX, ipAddress string) ([]*PeersTable, error) {
	rows, err := db.Query(ctx, connectClient, ipAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PeersTable{}
	for rows.Next() {
		var i PeersTable
		if err := rows.Scan(
			&i.ID,
			&i.PeerID,
			&i.IpAddress,
			&i.Pem,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createClient = `-- name: CreateClient :many
INSERT INTO peers_table(peer_id,ip_address, PEM )
VALUES  (default,$1, $2)
RETURNING (peer_id)
`

type CreateClientParams struct {
	IpAddress string `json:"ip_address"`
	Pem       []byte `json:"pem"`
}

// CreateClient
//
//	INSERT INTO peers_table(peer_id,ip_address, PEM )
//	VALUES  (default,$1, $2)
//	RETURNING (peer_id)
func (q *Queries) CreateClient(ctx context.Context, db DBTX, arg *CreateClientParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, createClient, arg.IpAddress, arg.Pem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var peer_id pgtype.UUID
		if err := rows.Scan(&peer_id); err != nil {
			return nil, err
		}
		items = append(items, peer_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPem = `-- name: GetAllPem :many
SELECT (pem) FROM peers_table
`

// GetAllPem
//
//	SELECT (pem) FROM peers_table
func (q *Queries) GetAllPem(ctx context.Context, db DBTX) ([][]byte, error) {
	rows, err := db.Query(ctx, getAllPem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := [][]byte{}
	for rows.Next() {
		var pem []byte
		if err := rows.Scan(&pem); err != nil {
			return nil, err
		}
		items = append(items, pem)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileData = `-- name: GetFileData :many
SELECT (
    peer_id,
    file_state,
    file_data
) FROM file_storage 
WHERE file_hash = $1
LIMIT 1
`

// GetFileData
//
//	SELECT (
//	    peer_id,
//	    file_state,
//	    file_data
//	) FROM file_storage
//	WHERE file_hash = $1
//	LIMIT 1
func (q *Queries) GetFileData(ctx context.Context, db DBTX, fileHash *string) ([]interface{}, error) {
	rows, err := db.Query(ctx, getFileData, fileHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []interface{}{}
	for rows.Next() {
		var column_1 interface{}
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFiles = `-- name: GetFiles :many
SELECT (
    file_name,
    file_path,
    file_type,
    modification_date,
    file_state,
    file_hash,
    prev_file_hash
) FROM file_storage 
WHERE peer_id = $1
`

// GetFiles
//
//	SELECT (
//	    file_name,
//	    file_path,
//	    file_type,
//	    modification_date,
//	    file_state,
//	    file_hash,
//	    prev_file_hash
//	) FROM file_storage
//	WHERE peer_id = $1
func (q *Queries) GetFiles(ctx context.Context, db DBTX, peerID uuid.UUID) ([]interface{}, error) {
	rows, err := db.Query(ctx, getFiles, peerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []interface{}{}
	for rows.Next() {
		var column_1 interface{}
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFile = `-- name: InsertFile :one
INSERT INTO file_storage (
    peer_id,
    file_name,
    file_path,
    file_type,
    modification_date,
    file_state,
    file_data
) VALUES ( 
    $1, $2, $3, $4, $5, $6, $7
) RETURNING (
    id,
    file_hash
)
`

type InsertFileParams struct {
	PeerID           uuid.UUID          `json:"peer_id"`
	FileName         string             `json:"file_name"`
	FilePath         string             `json:"file_path"`
	FileType         string             `json:"file_type"`
	ModificationDate pgtype.Timestamp   `json:"modification_date"`
	FileState        NullFileStatusType `json:"file_state"`
	FileData         []byte             `json:"file_data"`
}

// InsertFile
//
//	INSERT INTO file_storage (
//	    peer_id,
//	    file_name,
//	    file_path,
//	    file_type,
//	    modification_date,
//	    file_state,
//	    file_data
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7
//	) RETURNING (
//	    id,
//	    file_hash
//	)
func (q *Queries) InsertFile(ctx context.Context, db DBTX, arg *InsertFileParams) (interface{}, error) {
	row := db.QueryRow(ctx, insertFile,
		arg.PeerID,
		arg.FileName,
		arg.FilePath,
		arg.FileType,
		arg.ModificationDate,
		arg.FileState,
		arg.FileData,
	)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}
